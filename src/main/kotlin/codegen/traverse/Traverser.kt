package codegen.traverse

import codegen.*
import scheme.Tree
import java.io.ByteArrayOutputStream
import java.io.OutputStream
import java.nio.charset.Charset
import kotlin.random.Random

/**
 * Uses the tree to generate concrete code for each node
 * @param tree is generated by [TreeBuilder]
 */
class Traverser(private val tree: Tree) {

    val heads: MutableList<GenNode> = mutableListOf()

    /**
     * Traverses each head and builds top level objects
     */
    fun traverse() {
        tree.heads.forEachIndexed { idx, head ->
            assert(head.type == Elem.OBJECT)
            val genNode = buildObject(0)
            heads.add(genNode)
            processChildren(head, genNode)
            val baos = ByteArrayOutputStream()
            gatherObjectBody(genNode, baos)
            genNode.body = "\n" + baos.toString(Charset.defaultCharset())
        }
    }

    /**
     * Builds an object. Generates its name, attributes, text body
     */
    private fun buildObject(depth: Int, parent: GenNodeObject? = null): GenNodeObject {
        val obj = GenNodeObject()
        obj.name = generateObjectName()
        obj.type = Elem.OBJECT
        val freeAttributesNumber = rand(0, 3).coerceAtMost(rand(0, 4))
        for (i in 0 until freeAttributesNumber) {
            obj.freeAttributesList.add(generateFreeAttrName())
        }
        obj.depth = depth
        obj.body = generateObject(obj)
        obj.parent = parent
        allObjects.add(obj)
        return obj
    }

    private fun processChildren(treeNode: Tree.Node, objectNode: GenNodeObject) {
        treeNode.children.forEach { child ->
            when (child.type) {
                Elem.OBJECT -> {
                    val genNode = buildObject(objectNode.depth + 1, objectNode)
                    processChildren(child, genNode)
                    objectNode.children.add(genNode)
                    val baos = ByteArrayOutputStream()
                    gatherObjectBody(genNode, baos)
                    genNode.body = "\n" + baos.toString(Charset.defaultCharset())
                    genNode.children.clear()
//                    objectNode.children.clear()
                }

                Elem.STATE_OBJECT -> {
                    val genNode = GenNode()
                    genNode.name = generateAttrName()
                    genNode.parent = objectNode
                    genNode.depth = objectNode.depth + 1
                    val value = if (rand(0, 3) < 2) {
                        val l = allObjects
                            .filter { it.depth <= objectNode.depth && it.name != "@" && sameSubtree(it, genNode) }
                            .shuffled()
                        if (l.isNotEmpty()) l[0].name
                        else randomString()
                    } else randomString()
                    genNode.body = generateStateAttr(genNode.name, value, genNode.depth)
                    allObjects.add(genNode)
                    objectNode.children.add(genNode)
                }

                Elem.DECORATION -> {
                    val genNode = GenNode()
                    genNode.name = "@"
                    genNode.parent = objectNode
                    genNode.depth = objectNode.depth + 1
                    val value = if (rand(0, 3) < 2) {
                        val l = allObjects
                            .filter { it.depth <= objectNode.depth && it.name != "@" && sameSubtree(it, genNode) }
                            .shuffled()
                        if (l.isNotEmpty()) l[0].name
                        else "QQ.io.stdout \"hehe\""
                    } else "QQ.io.stdout \"hehe\""
                    genNode.body = generateStateAttr(genNode.name, value, genNode.depth)
                    allObjects.add(genNode)
                    objectNode.children.add(genNode)
                }
                Elem.DOT -> {}
            }
        }
    }

    private fun sameSubtree(node1: GenNode, node2: GenNode): Boolean {
        var tmpCreated = node1
        while (tmpCreated.depth > node2.depth) {
            tmpCreated = tmpCreated.parent!!
        }
        var tmpValue = node2
        while (tmpValue.depth > node1.depth) {
            tmpValue = tmpValue.parent!!
        }
        return tmpCreated.parent == tmpValue.parent
    }

    private fun gatherObjectBody(node: GenNode, outputStream: OutputStream) {
        outputStream.write(node.body.toByteArray())
        node.children.forEach { gatherObjectBody(it, outputStream) }
    }

    private fun randomString(): String {
        val charPool: List<Char> = ('a'..'z') + ('A'..'Z') + ('0'..'9')
        return "\"${
            (3..rand(5, 17))
                .map { Random.nextInt(0, charPool.size).let { charPool[it] } }
                .joinToString("")
        }\""
    }
}

/**
 * Representation of a node. Depth is the depth of the current node in a program, body is the code of the object
 */
open class GenNode {
    val children: MutableList<GenNode> = mutableListOf()
    var body = ""
    var depth = 0
    var name = ""
    var parent: GenNodeObject? = null
    lateinit var type: Elem
}

class GenNodeObject : GenNode() {
    val freeAttributesList = mutableListOf<String>()
}

/**
 * All the objects that are present in the program
 */
val allObjects = mutableListOf<GenNode>()